---
title: 잘못된 스플래시 유저 경험을 개선하기
date: '2025-10-23T10:44:03.284Z'
tags: ['DEV', 'Node.js', 'Performance']
summary: 직렬을 병렬 처리로 그리고 필요한 타이밍에 스플래시 끄기
---

# TL;DR

[포도스피킹](https://podospeaking.com/)의 프론트엔드 개발을 맡은 지 대략 1년이 지났습니다. 25년 3월 25일 React Native로 네이티브 영역을 페이스리프팅하고, 이후 안정화 및 최적화 작업을 수행하면서 그동안 간과했던 사용자 경험 요소들을 면밀히 검토하는 계기가 되었습니다.

사용자 피드백을 분석하던 중 앱 구동 속도에 대한 불만이 다수 발견되었습니다. 개발 과정에서 반복적으로 접하다 보니 둔감해졌지만, 신규 사용자 관점에서는 체감 속도가 느릴 수밖에 없었습니다. 병목 지점을 파악해보니 스플래시 화면 표시부터 웹뷰 초기 로딩 완료까지의 구간에서 상당한 지연이 발생하고 있었습니다.

그렇게 되어서 스플래시 관련하여 궁금한것을 **GPT** 한테 물어보았습니다.

## 하이브리드 웹앱에서 스플래시란 무엇일까??

> **하이브리드 웹앱의 스플래시**는 앱을 실행했을 때 웹뷰와 리소스가 로드되는 동안 사용자가 보게 되는 **첫 화면(로딩/브랜딩 화면)** 입니다.

## 그러면 스플래시가 숨겨지는 타이밍은 어떻게 되는것이 좋을까?

> 좋은 스플래시 해제 타이밍은 “사용자가 멈춤을 느끼지 않으면서, 핵심 UI의 첫 인상이 깨지지 않는 시점”입니다.

# 아차 싶었던 포인트

다시 한번 포도의 스플래시 화면부터 첫 화면 진입까지의 과정을 면밀히 살펴보았습니다.

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
  <Image src="/static/images/DEV/splash-ux/as-is-splash.gif" alt="as-is-splash" width={200} height={500} />
</div>

스플래시 이미지가 종료된 후 웹뷰를 로딩하고 화면이 그려지기 시작합니다. 그런데 문제는 여기서부터입니다. 웹뷰가 HTML 문서를 전달받아 화면에 렌더링한 이후에도, 여러 페이지를 거쳐 리다이렉션하면서 최종적으로 사용자가 실제로 사용할 화면에 도달하는 구조였습니다.

### 문제의 핵심

1. **스플래시 종료 ≠ 앱 사용 가능**

스플래시가 사라져도 사용자는 여전히 기다려야 합니다.

2. **여러번의 리다이렉션**

메인 도메인 → 인증 확인 → 콜백 처리 → 최종 목적지까지 최소 3~4번의 페이지 전환이 발생합니다.

3. **각 단계마다 발생하는 지연**
   - 페이지 요청/응답 왕복 시간
   - 각 페이지의 초기 렌더링 시간
   - 리다이렉트 로직 실행 시간

결국 사용자는 스플래시 화면이 사라진 후에도 빈 화면이나 로딩 상태를 추가로 보게 되며, 이것이 "앱이 느리다"는 피드백의 주요 원인이었을 것입니다.

## 현재 리다이렉션 플로우 분석

정확히 어떤 단계를 거치는지 파악해보니 총 4단계의 리다이렉션이 발생하고 있었습니다.

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
  <Image src="/static/images/DEV/splash-ux/as-is-flow.png" alt="as-is-flow" width={200} height={500} />
</div>

각 단계를 거칠 때마다 다음과 같은 작업들이 순차적으로 실행됩니다.

1. **초기 진입 페이지 로드** - destination 파라미터 확인
2. **인증 API 호출** - 사용자 인증 상태 검증
3. **리다이렉트 콜백 처리** - 인증 결과에 따른 분기 처리
4. **최종 목적지 렌더링** - 실제 사용자가 볼 화면 표시

문제는 이 모든 과정이 **직렬로** 처리된다는 점입니다. 각 단계가 완료되어야 다음 단계로 넘어갈 수 있기 때문에, 네트워크 지연이나 처리 시간이 누적되어 체감 속도가 느려질 수밖에 없었습니다.

## 개선 방향 고민

이 문제를 해결하기 위해 두 가지 핵심 질문에 집중했습니다.

### 1. 리다이렉션 단계를 어떻게 줄일 수 있을까?

현재 4단계로 나뉜 리다이렉션을 줄이기 위해 다음과 같은 방법들을 검토했습니다.

- **불필요한 중간 단계 제거** - 꼭 필요한 단계인지 재검토
- **병렬 처리 가능한 작업 분리** - 인증 확인과 다른 작업을 동시에 처리
- **클라이언트 사이드에서 직접 처리** - 서버 리다이렉트를 클라이언트 라우팅으로 대체

### 2. 스플래시를 끄는 시점을 어떻게 최적화할까?

스플래시를 너무 일찍 끄면 사용자는 빈 화면이나 로딩 인디케이터를 보게 되고, 너무 늦게 끄면 불필요하게 대기 시간이 길어집니다. 따라서 다음과 같은 조건을 만족하는 시점을 찾아야 했습니다.

- **최소 요구사항**: 웹뷰가 초기화되고 HTML 문서 로딩이 완료된 시점
- **이상적인 시점**: 사용자가 상호작용 가능한 핵심 UI가 렌더링된 시점
- **실용적인 타협점**: 첫 화면의 레이아웃이 그려지고 주요 콘텐츠가 보이기 시작하는 시점

# 개선 방안 적용하기

## 1. 네이티브 스플래시 구성 추가

앱 실행 직후 즉시 스플래시를 표시하기 위해 네이티브 레벨에서 스플래시 화면을 구성했습니다.

### app.config.ts 설정

```typescript
export default {
  splash: {
    image: './assets/splash.png',
    resizeMode: 'contain',
    backgroundColor: '#ffffff'
  }
}
```

이렇게 하면 앱이 시작되는 순간부터 네이티브 스플래시가 표시되어 초기 흰 화면을 방지할 수 있습니다.

## 2. 네이티브 레이어: 스플래시 제어 로직

### _layout.tsx: 이중 조건 체크로 스플래시 해제

```typescript
// apps/native/src/app/_layout.tsx
import { useBridge } from '@webview-bridge/react-native'
import { appBridge } from 'core/app-bridge'
import * as SplashScreen from 'expo-splash-screen'
import { useEffect, useState } from 'react'

// 네이티브 스플래시 옵션 설정
SplashScreen.setOptions({
  duration: 1000,  // 1초 페이드 아웃
  fade: true,      // 페이드 효과 활성화
})

// 자동 숨김 방지 - 직접 제어하기 위함
SplashScreen.preventAutoHideAsync()

const MIN_SPLASH_MS = 4000 // 최소 4초 노출

const RootLayout = () => {
  const [isSplashMinShown, setIsSplashMinShown] = useState(false)

  // 브리지를 통해 웹 앱의 로드 상태 구독
  const { appLoaded, appStartedAt } = useBridge(appBridge, (state) => ({
    appLoaded: state.appLoaded,
    appStartedAt: state.appStartedAt,
  }))

  // ✅ 조건 1: 최소 스플래시 노출 시간 보장
  useEffect(() => {
    const elapsed = Date.now() - appStartedAt
    const remaining = Math.max(0, MIN_SPLASH_MS - elapsed)
    const timer = setTimeout(() => setIsSplashMinShown(true), remaining)
    return () => clearTimeout(timer)
  }, [appStartedAt])

  // ✅ 조건 2: 웹 앱 로드 완료 확인
  // 두 조건이 모두 충족되면 스플래시 숨김
  useEffect(() => {
    if (appLoaded && isSplashMinShown) {
      SplashScreen.hideAsync()
    }
  }, [appLoaded, isSplashMinShown])

  return <Stack screenOptions={{ headerShown: false }} />
}
```

### app-bridge.ts: 브리지 상태 정의

```typescript
// apps/native/src/core/app-bridge.ts
export type AppBridgeState = {
  appStartedAt: number      // 앱 시작 시간
  appLoadedAt: number       // 앱 로드 완료 시간
  appLoaded: boolean        // 웹 앱 로드 완료 여부
  safeAreaBackgroundColor: string
  useSafeArea: boolean
  // ...
}

export type AppBridgeAction = {
  setAppLoaded: () => Promise<void>
  setSafeAreaBackgroundColor: (color: string) => Promise<void>
  setUseSafeArea: (use: boolean) => Promise<void>
  // ...
}

export const appBridge = bridge<AppBridgeState & AppBridgeAction>(({ set }) => ({
  // 초기 상태
  appStartedAt: Date.now(),  // 앱 시작 시간 기록
  appLoadedAt: 0,
  appLoaded: false,
  safeAreaBackgroundColor: '#FFFFFF',
  useSafeArea: true,

  // 웹 앱에서 호출할 액션
  setAppLoaded: async () => {
    set({ appLoaded: true, appLoadedAt: Date.now() })
  },

  setSafeAreaBackgroundColor: async (safeAreaBackgroundColor) => {
    set({ safeAreaBackgroundColor })
  },

  setUseSafeArea: async (useSafeArea) => {
    set({ useSafeArea })
  },
}))
```

### 작동 원리

스플래시 해제는 **두 가지 조건을 모두 만족**해야 실행됩니다:

1. **시간 조건**: 앱 시작 후 최소 4초 경과 (`isSplashMinShown = true`)
2. **로딩 조건**: 웹 앱에서 `setAppLoaded(true)` 호출 (`appLoaded = true`)

![](/static/images/DEV/splash-ux/to-be-flow-condition.png)

**핵심 장점:**
- 앱이 **빠르게 로드**되어도 최소 4초는 스플래시를 유지 → 깜빡임 방지
- 앱 로딩이 **오래 걸려도** 로드 완료를 기다림 → 빈 화면 방지
- `SplashScreen.setOptions`의 `fade: true`로 1초 부드러운 전환

## 3. 웹 레이어: 브리지를 통한 로드 완료 신호 전송

### native-bridge-store.provider.tsx: 웹에서 브리지 액션 위임

```typescript
// apps/web/src/core/providers/native-bridge-store.provider.tsx
import { useBridge } from '@webview-bridge/web'
import { appBridge } from '@native/core/app-bridge'

export const NativeBridgeStoreProvider = ({ children }) => {
  const webBridge = useBridge(appBridge)

  // 네이티브 브리지 상태를 웹 앱에서 사용 가능하도록 제공
  const nativeStore = {
    // 브리지 상태 구독
    appLoaded: webBridge.appLoaded,
    safeAreaBackgroundColor: webBridge.safeAreaBackgroundColor,
    useSafeArea: webBridge.useSafeArea,

    // 브리지 액션 위임
    setAppLoaded: (isLoaded: boolean) => webBridge.setAppLoaded(isLoaded),
    setSafeAreaBackgroundColor: (color: string) =>
      webBridge.setSafeAreaBackgroundColor(color),
    setUseSafeArea: (use: boolean) =>
      webBridge.setUseSafeArea(use),
  }

  return (
    <NativeBridgeContext.Provider value={nativeStore}>
      {children}
    </NativeBridgeContext.Provider>
  )
}
```

### use-auth-redirect.ts: 실제 호출 지점

```typescript
// apps/layers/features/src/auth/hooks/use-auth-redirect.ts
import { useNativeBridge } from '@web/core/providers/native-bridge-store.provider'

export const useAuthRedirect = () => {
  const nativeStore = useNativeBridge()

  useEffect(() => {
    const handleAuthRedirect = async () => {
      try {
        // 인증 리다이렉트 로직 수행
        await processAuthRedirect()

        // 인증 완료 후 네이티브에 앱 로드 완료 신호 전송
        await nativeStore.setAppLoaded(true)
      } catch (error) {
        // 에러 발생 시에도 스플래시 해제를 위해 신호 전송
        await nativeStore.setAppLoaded(true)

        if (isRedirectError(error)) {
          // 에러 처리...
        }
      }
    }

    handleAuthRedirect()
  }, [])
}
```

### 전체 흐름

![](/static/images/DEV/splash-ux/to-be-sequence.png)

**핵심 포인트:**
- 웹 앱이 **실제로 사용 가능한 시점**에 `setAppLoaded(true)` 호출
- 인증 리다이렉트 흐름이 완료된 후 신호 전송
- 에러 발생 시에도 스플래시가 영구적으로 남지 않도록 `catch` 블록에서도 호출

## 4. 초기 페인트 안정성 향상

### app-bridge.ts: 안전 영역 배경색 상태 관리

```typescript
export type AppBridgeState = {
  safeAreaBackgroundColor: string  // 안전 영역 배경색
  useSafeArea: boolean             // 안전 영역 사용 여부
  // ...
}

export const appBridge = bridge<AppBridgeState & AppBridgeAction>(({ set }) => ({
  safeAreaBackgroundColor: '#FFFFFF',  // 기본값
  useSafeArea: true,

  setSafeAreaBackgroundColor: async (safeAreaBackgroundColor) => {
    set({ safeAreaBackgroundColor })
  },

  setUseSafeArea: async (useSafeArea) => {
    set({ useSafeArea })
  },
}))
```

### 웹 앱에서 안전 영역 배경색 제어

```typescript
// 웹 앱에서 페이지별로 배경색 설정
function HomePage() {
  const bridge = useBridge(appBridge)

  useEffect(() => {
    // 페이지 진입 시 안전 영역 배경색 변경
    bridge.setSafeAreaBackgroundColor('#F5F5F5')

    return () => {
      // 페이지 이탈 시 원래대로
      bridge.setSafeAreaBackgroundColor('#FFFFFF')
    }
  }, [])

  return <div>홈 페이지</div>
}
```

브리지를 통해 안전 영역 배경색을 일관되게 관리함으로써 페이지 전환 시 깜빡임과 레이아웃 점프를 최소화했습니다.

## 5. 스플래시 애니메이션 품질 개선

### splash.tsx: Lottie 애니메이션 루프

```typescript
import LottieView from 'lottie-react-native';

export const Splash = () => {
  return (
    <LottieView
      source={require('./splash-animation.json')}
      autoPlay
      loop // 애니메이션 끊김 없이 계속 재생
      style={{ width: '100%', height: '100%' }}
    />
  );
};
```

`loop` 옵션을 활성화하여 오버레이가 해제될 때까지 애니메이션이 자연스럽게 이어지도록 했습니다.

## 6. 빌드 안정성 패치

```json
{
  "dependencies": {
    "react-native": "0.79.6",
    "lottie-react-native": "7.3.4"
  }
}
```

```json
{
  "scripts": {
    "prebuild": "expo prebuild",
    "android": "expo run:android",
    "ios": "expo run:ios"
  }
}
```

- React Native와 Lottie 라이브러리를 최신 안정 버전으로 업그레이드
- 빌드 스크립트에 `expo prebuild`를 포함하여 네이티브 리소스 동기화 누락 방지

# 개선 결과

## Before vs After

### Before

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
  <Image src="/static/images/DEV/splash-ux/as-is-flow-fail.png" alt="as-is-flow-fail" width={200} height={500} />
</div>

**문제점:**
- 네이티브 스플래시가 빠르게 사라짐
- WebView 로딩 중 흰 화면 노출
- 앱 로드 상태 체크 없음

### After

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
  <Image src="/static/images/DEV/splash-ux/to-be-splash.gif" alt="to-be-splash" width={400} height={500} />
</div>

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
  <Image src="/static/images/DEV/splash-ux/to-be-flow-success.png" alt="to-be-flow-success" width={400} height={500} />
</div>

**개선점:**
- 네이티브 스플래시가 자동으로 숨겨지지 않음 (`preventAutoHide`)
- 최소 4초 보장 + 앱 로드 완료 확인
- 브리지를 통한 정확한 상태 전달
- 1초 페이드 아웃으로 부드러운 전환

## 체감 효과 요약

### 시각적 개선
- **앱 실행 직후 즉시 스플래시 노출** - 초기 흰 화면 완전 제거
- **부드러운 전환** - 네이티브 스플래시 → 오버레이 → 실제 화면으로 자연스러운 전환
- **깜빡임 최소화** - 안전 영역 배경색 일관화로 레이아웃 점프 감소

### 로딩 경험 개선
- **최소 4초 노출** - 너무 짧은 스플래시로 인한 깜빡임 방지
- **이중 조건 체크** - 시간 조건(4초)과 로딩 조건(앱 로드 완료)을 모두 만족해야 해제
- **1초 페이드 아웃** - `SplashScreen.setOptions`로 자연스러운 전환
- **브리지 기반 제어** - 웹 앱이 실제로 사용 가능한 시점에 네이티브에 알림

### 안정성 향상
- **이중 조건 체크** - 시간과 로딩 상태 모두 확인하여 안정적인 스플래시 해제
- **브리지 기반 통신** - React Native ↔ 웹 앱 간 명확한 상태 공유
- **네이티브 리소스 동기화** - `expo prebuild`로 빌드 관련 이슈 사전 방지

## 실제 측정 결과

| 지표 | Before | After | 개선 효과 |
|-----|--------|-------|----------|
| 초기 흰 화면 노출 | 발생 | 제거 | **네이티브 스플래시 즉시 표시** |
| 스플래시 최소 시간 | 불안정 | 4초 보장 | **깜빡임 방지** |
| 페이드 전환 | 없음 | 1초 페이드 | **부드러운 전환** |
| 앱 로드 체크 | 없음 | 브리지로 확인 | **정확한 타이밍** |
| 안전 영역 일관성 | 불안정 | 브리지로 통합 관리 | **시각적 안정성** |

# 배운 점

## 1. 네이티브와 웹의 경계를 이해하기

하이브리드 앱에서는 네이티브 스플래시와 웹뷰 로딩 사이의 간극이 사용자 경험을 크게 좌우합니다. 단순히 WebView의 `onLoad` 이벤트에 의존하면 HTML 문서가 로드된 시점만 알 수 있지, 실제 React 앱이 사용 가능한 시점은 알 수 없습니다. **브리지를 통한 명시적인 신호 전달**이 핵심입니다.

## 2. 타이밍이 전부다

스플래시를 언제 보여주고 언제 숨길지에 대한 섬세한 제어가 체감 속도를 결정합니다.

- **너무 이르면**: 깜빡임 발생, 불완전한 화면 노출
- **너무 늦으면**: 답답함, "앱이 느리다"는 인식

우리는 **이중 조건 체크**(최소 4초 + 앱 로드 완료)로 이 균형을 맞췄습니다.

## 3. 방어적 프로그래밍의 중요성

```typescript
try {
  await processAuthRedirect()
  await nativeStore.setAppLoaded(true)
} catch (error) {
  // 에러 발생 시에도 스플래시 해제!
  await nativeStore.setAppLoaded(true)
  // ...
}
```

네트워크 지연, 인증 실패 등 예상치 못한 상황에서도 사용자가 멈춤 없이 앱을 사용할 수 있도록 `catch` 블록에서도 `setAppLoaded`를 호출하는 것이 중요합니다.

## 4. 브리지 아키텍처의 위력

`@webview-bridge` 라이브러리를 통해:
- 네이티브 ↔ 웹 간 **타입 안전한** 통신
- **양방향 상태 동기화** (네이티브에서 구독, 웹에서 변경)
- **명확한 책임 분리** (네이티브는 UI 제어, 웹은 비즈니스 로직)

이 구조 덕분에 스플래시 타이밍, 안전 영역 배경색 등을 일관되게 관리할 수 있었습니다.

## 5. 작은 개선의 누적 효과

- 네이티브 스플래시 추가 (`app.config.ts`)
- 자동 숨김 방지 (`preventAutoHideAsync`)
- 최소 노출 시간 설정 (4초)
- 페이드 효과 (`fade: true, duration: 1000`)
- 브리지 기반 로드 완료 체크
- 안전 영역 배경색 통일

하나하나는 작은 개선이지만, 이들이 모여 전체적인 사용자 경험을 크게 향상시킵니다.

# 더 물어볼 만한 주제

- **스플래시 화면의 최적 지속 시간은?** - 너무 짧으면 깜빡임, 너무 길면 답답함
- **웹뷰 프리로딩 vs 지연 로딩** - 어느 전략이 체감 속도를 개선할까?
- **스플래시 디자인이 UX에 미치는 영향** - 단순 로고 vs 프로그레스 바 vs 애니메이션
- **네이티브 vs 웹 기반 스플래시의 차이점** - 각각의 장단점과 구현 방식
- **초기 로딩 성능 측정 방법** - Time to Interactive, First Contentful Paint 등의 메트릭
- **콜드 스타트 vs 웜 스타트 최적화** - 앱 재실행 시 다른 전략이 필요할까?
- **스플래시 이후의 화면 전환 전략** - Fade out, 슬라이드, 즉시 전환 중 무엇이 자연스러울까?

# 마치며

"앱이 느리다"는 단순한 피드백 하나가, 스플래시 화면부터 초기 로딩 플로우 전체를 돌아보는 계기가 되었습니다. 개발자로서 익숙해진 환경에서는 놓치기 쉬운 사용자 경험의 세부 사항들을 다시 한번 점검할 수 있었고, 작은 개선들이 모여 큰 차이를 만든다는 것을 체감할 수 있었습니다.

여러분의 앱도 혹시 초기 로딩에서 사용자가 불편을 느끼고 있지는 않나요? 한번 천천히 들여다보시길 추천드립니다.
