---
title: '멀티존 마이크로 프론트엔드로 쿠키 공유 문제 해결하기'
summary: '기술부채 청산과 조직의 목표를 함께'
date: '2025-08-07'
tags: ['DEV', 'FRONTEND']
draft: false
---

## TL;DR

- 세 개의 다른 프론트엔드(Next.js, Nuxt.js, PHP)가 도메인이 달라 쿠키를 공유하지 못하는 문제가 있었음
- Next.js의 Multi-Zone + Rewrites 기능을 활용해 단일 도메인 하에 통합
- 인증 쿠키 공유, 데이터 분석 정확도 개선, 사용자 경험 개선 등 다양한 효과
- 특히 GA 트래킹 문제(`not set`)를 해결하고, 데이터 기반 의사결정이 가능해짐

---

포도스피킹에 입사하고 가장 먼저 마주친 문제는 로그인이었다. 한 번 로그인하려면 여러 도메인을 거쳐야 하고, 개발할 때마다 쿠키 때문에 골치가 아팠다. 처음엔 그냥 불편한 정도로 생각했는데, 알고 보니 이게 우리 조직 전체의 개발 속도를 늦추고 사용자 경험까지 망가뜨리는 심각한 문제였다.

## 어쩌다 이렇게 됐을까

포도스피킹의 프론트엔드는 시간이 지나면서 자연스럽게 여러 개가 생겼다. 옛날 시스템을 완전히 갈아엎기보다는 새로운 기술로 새 기능을 만들어가다 보니, 결국 3개의 서로 다른 프론트엔드가 공존하게 된 거다.

### 우리 서비스의 역사

**PHP (2024년 이전)**
- 가장 오래된 레거시 of 레거시
- 운영팀이 가장 익숙한 기술
- 운영 관리 페이지 담당
- PHP 세션 기반 인증

**Nuxt.js (2024년)**
- 2024년 초에 새로 만든 "신규 레거시"
- 기존 Vue 기반에서 발전시킨 버전
- 기존 기능들을 담당
- 브라우저 쿠키 기반 인증

**Next.js (2025년)**
- 2025년에 레거시를 정리하려고 만든 진짜 신규
- React 기반으로 점진적 이전
- 새로운 기능들 담당
- HttpOnly 쿠키 기반 인증

각자 나름의 이유가 있었지만, 결과적으로는 3개의 완전히 다른 시스템이 됐다.

## 문제의 핵심: 쿠키

<Mermaid chart={`
graph TD
    %% 외부 진입
    subgraph 외부채널["외부 채널"]
        Marketing["podospeaking.com<br/>(마케팅 사이트)"]
        MobileApp["모바일 앱<br/>(WebView)"]
        DeepLink["딥링크 또는 외부 링크"]
    end

    %% 진입점
    Marketing -->|로그인 클릭| Gateway["podo.re-speak.com<br/>(Next.js Gateway)"]
    MobileApp -->|로그인| Gateway
    DeepLink -->|accessToken 포함된 진입| Gateway

    %% 게이트웨이 처리 로직
    Gateway -->|accessToken 없음 또는 만료| Login["podo.re-speak.com/login"]
    Gateway -->|accessToken 유효| Redirect["Redirect → destination"]

    %% 리디렉션 대상 (하드 네비게이션)
    subgraph TargetApps["목적지 앱들"]
        NuxtZone["Zone A: Nuxt.js<br/>브라우저 쿠키 기반 인증"]
        PHPZone["Zone B: PHP<br/>PHP 세션 기반 인증"]
        NextZone["Zone C: Next.js<br/>HTTP Only 쿠키 기반 인증"]
    end

    Redirect -->|하드 네비게이션| NuxtZone
    Redirect -->|하드 네비게이션| PHPZone
    Redirect -->|하드 네비게이션| NextZone

    %% 스타일링
    classDef gatewayStyle fill:#e1f5fe,stroke:#0277bd,stroke-width:2px
    classDef zoneStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef externalStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px

    class Gateway gatewayStyle
    class NuxtZone,PHPZone,NextZone zoneStyle
    class Marketing,MobileApp,DeepLink externalStyle
`} />

### 브라우저가 쿠키 공유를 막는다

브라우저는 보안상 같은 도메인끼리만 쿠키를 공유한다. 우리 3개 프론트엔드는 각각 다른 도메인에 있었다:

```
next.js: https://podo.re-speak.com      🍪
nuxt.js: https://app.podo-speaking.com  🍪
php:     https://admin-server.com       🍪
```

당연히 쿠키를 공유할 수 없었다.

### 각자 다른 방식으로 인증 처리

더 골치 아픈 건 각자 인증하는 방식도 달랐다는 점이다:

- **Next.js**: HttpOnly 쿠키로 안전하게
- **Nuxt.js**: 일반 브라우저 쿠키로
- **PHP**: 옛날 방식 세션으로
- **쿠키 이름까지 다 달랐음**

사용자 로그인 상태가 앱들 사이에서 전혀 공유가 안 됐다.

### 미친 11단계 로그인 과정

실제로 사용자가 로그인하면 이런 복잡한 과정을 거쳐야 했다:

<Mermaid chart={`
sequenceDiagram
    participant User as 사용자 브라우저
    participant NextJS as podo.re-speak.com (Next.js)
    participant Kakao as Kakao OAuth
    participant API as API 서버
    participant NuxtJS as app.podo-speaking.com (Nuxt.js)

    User->>NextJS: 1. 사용자가 로그인 페이지 접속 (/login)
    NextJS->>Kakao: 2. 카카오 로그인 버튼 클릭
    Kakao-->>NextJS: 3. 인증 코드 전달 (Redirect)
    NextJS->>API: 4. 인증 코드 전달 (/api/v1/oauth/kakao)
    API-->>NextJS: 5. access_token, refresh_token, uid 등 전달

    Note over NextJS: 6. podo.re-speak.com 도메인에<br/>쿠키 저장 (access_token 등)
    Note over NextJS: 7. destination=HOME으로 리다이렉트

    NextJS-->>User: 8. https://podo.re-speak.com?destination=HOME
    NextJS->>User: 9. 쿠키 세팅된 상태로 전달 (?destination=HOME)

    Note over User: 10. access_token, refresh_token, uid를<br/>쿼리파라미터로 전달

    User->>NuxtJS: 11. app.podo-speaking.com으로 리다이렉트
    User->>NuxtJS: 12. access_token 등을 전달<br/>(/app/user/podo/home?access_token=xxx&refresh_token=yyy&uid=zzz)
    NuxtJS-->>User: 13. 홈 화면 렌더링 (URL에서 토큰 추출 후 저장)

    %% 스타일링
    Note over User, NuxtJS: 복잡한 11단계 인증 플로우
`} />

총 11단계나 되는 복잡한 과정이었다.

### URL에 토큰을 넘기는 방식의 문제들

토큰을 URL 파라미터로 넘기는 방식은 정말 문제가 많았다:

**토큰 관리가 복잡해짐**
- URL로 토큰을 주고받으니 상태 관리가 엉망
- 여러 도메인 간에 토큰 동기화가 안 됨

**사용자 경험 최악**
- URL이 길어져서 보기 싫음
- 주소창에 이상한 파라미터들이 주르륵

**개발자도 괴로움**
- 각 도메인마다 토큰 처리하는 코드 따로 작성
- 디버깅할 때 복잡한 리다이렉트 흐름 따라가기 힘듦

## 해결책 찾기

### 고려했지만 선택하지 않았던 방법들

**CDN으로 해보자**

CDN Behavior 설정으로 라우팅하는 방법을 생각해봤다.

좋은 점:
- 애플리케이션 코드는 거의 안 건드려도 됨
- 각 존별로 독립적으로 캐싱 가능
- CDN 엣지에서 처리해서 빠름

안 좋은 점:
- CDN 설정이 너무 복잡함
- 디버깅이 어려움

**프록시 서버로 해보자**

Nginx 같은 프록시 서버로 라우팅하는 방법도 생각해봤다.

좋은 점:
- 세밀한 라우팅 제어 가능
- 헤더와 쿠키 조작할 수 있음
- 로드밸런싱도 할 수 있음

안 좋은 점:
- 인프라 관리할 게 더 많아짐
- 하나 죽으면 전체가 죽음
- 응답이 늦어짐

두 방법 다 "너무 할게 많다"는 결론에 도달했다.

## 구원자 Next.js Multizone

Next.js 공식문서를 뒤지다가 Multizone 아키텍처를 발견했다. 문서의 다이어그램을 보는 순간 "이거다!"라고 생각했다.

Next.js의 Rewrites 기능을 쓰면 Multi-Zone 마이크로 프론트엔드를 만들 수 있었다.

![](https://nextjs.org/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fmulti-zones.png&w=3840&q=75)

### Zone 구성

- **Zone A**: Next.js - 메인 앱 겸 새 기능들
- **Zone B**: Nuxt.js - 기존 기능들
- **Zone C**: PHP - 운영 관리 도구

### 라우팅을 두 가지로 나눔

**Hard Navigation**:
- Zone 간 이동할 때 사용
- 페이지 전체가 새로고침됨
- 쿠키와 세션 정보는 그대로 유지

**Soft Navigation**:
- 각 Zone 안에서의 이동
- 클라이언트 사이드 라우팅
- 부드럽게 페이지 전환

### Next.js Rewrite로 구현

핵심은 이거다: 사용자가 보는 URL은 그대로인데, 실제로는 다른 서버로 요청을 보내는 것.

#### 고려해야 했던 것들

정적 파일들과 Path 규칙을 미리 파악해야 했다:
- Nuxt.js 정적파일들과 라우팅 규칙
- PHP 정적파일들과 라우팅 규칙

```javascript
const multiZoneConfig = {
  async rewrites() {
    const nuxtRewriteConfig = [
      {
        source: '/_nuxt/:path*',
        destination: `${env.NUXT_JS_URL}/_nuxt/:path*`,
      },
      {
        source: '/app/user/podo/:path*',
        destination: `${env.NUXT_JS_URL}/app/user/podo/:path*`,
      },
    ];

    const phpRewriteConfig = [
      {
        source: '/js/:path*',
        destination: `${env.PHP_URL}/js/:path*`,
      },
      {
        source: '/css/:path*',
        destination: `${env.PHP_URL}/css/:path*`,
      },
      {
        source: '/img/:path*',
        destination: `${env.PHP_URL}/img/:path*`,
      },
      {
        source: '/app/android/:path*',
        destination: `${env.PHP_URL}/app/android/:path*`,
      },
    ];

    return [...nuxtRewriteConfig, ...phpRewriteConfig];
  },
};
```

#### Next.js가 검사하는 순서

1. 헤더 확인하고 적용
2. 리디렉션 규칙 확인
3. 정적 파일 처리
   - beforeFiles (정적파일보다 우선 처리)
   - 정적파일 검사 (public/, _next/static)
   - afterFiles (정적파일이 없을 때 대부분 사용)
   - fallback (최종 백업)
4. 최종 응답 처리

### 쿠키 문제 해결

<Mermaid chart={`
sequenceDiagram
  participant Browser
  participant NextJS as Next.js
  participant Nuxt as Nuxt.js
  participant PHP as PHP

  Browser->>NextJS: GET /api/login
  NextJS->>Browser: Set-Cookie (SameSite=None/ Secure/ HttpOnly)

  Browser->>NextJS: GET /legacy/mypage
  NextJS->>Nuxt: Proxy + Cookie 전달
  Nuxt->>NextJS: 응답
  NextJS->>Browser: 렌더링 결과

  Browser->>NextJS: GET /support/inquiry
  NextJS->>PHP: Proxy + Cookie 전달
  PHP->>NextJS: 응답
  NextJS->>Browser: 렌더링 결과
`} />

```javascript
// Next.js에서 쿠키 설정
Set-Cookie: access_token=xxx; SameSite=None; Secure; HttpOnly
```

이제 모든 요청에 쿠키가 자동으로 포함돼서 각 존에서 인증 상태를 공유할 수 있게 됐다.

## 최종 결과물

### 완성된 아키텍처

<Mermaid chart={`
graph TB
    %% 사용자
    User[사용자]

    %% 브라우저와 도메인 엔트리
    subgraph Domain["단일 도메인: podo.re-speak.com"]
        %% Next.js App Shell (게이트웨이이면서 동시에 Zone)
        subgraph AppShell["Next.js App Shell"]
            Gateway[게이트웨이<br/>Rewrite 처리]
            NextZone[Next.js Zone<br/>신규 피처 담당]
        end

        %% Rewrite & Proxy 처리
        Gateway -.->|rewrite & proxy| NuxtZone
        Gateway -.->|rewrite & proxy| PHPZone
        Gateway -.->|내부 라우팅| NextZone
    end

    %% 각 존 (실제 서버들)
    subgraph Zones["독립적인 존들"]
        NuxtZone[Nuxt.js Zone<br/>app.podo-speaking.com<br/>레거시 기능<br/>원서버 프록시]
        PHPZone[PHP Zone<br/>운영 관리 페이지<br/>운영 도구<br/>원서버 프록시]
    end

    %% API 서버
    APIServer[(API 서버)]

    %% 데이터베이스
    Database[(Database)]

    %% 사용자 플로우
    User --> Domain

    %% 존에서 API 및 데이터베이스 접근
    NuxtZone --> APIServer
    PHPZone --> APIServer
    NextZone --> APIServer

    APIServer --> Database

    %% 스타일링
    classDef userStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef domainStyle fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    classDef gatewayStyle fill:#e1f5fe,stroke:#0277bd,stroke-width:2px
    classDef nextZoneStyle fill:#e8f5e8,stroke:#0277bd,stroke-width:2px
    classDef zoneStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef serverStyle fill:#fff3e0,stroke:#f57c00,stroke-width:2px

    class User userStyle
    class Domain domainStyle
    class Gateway gatewayStyle
    class NextZone nextZoneStyle
    class NuxtZone,PHPZone zoneStyle
    class APIServer,Database serverStyle
`} />

**무엇이 좋아졌나**
1. **하나의 문으로 들어감**: Next.js App shell을 통해 모든 게 연결됨
2. **점진적으로 바꿔감**: 기존 시스템 그대로 두고 새 기능 개발 가능
3. **인증 통합**: 복잡했던 인증 과정을 App Shell에서 한 번에 처리
4. **이중 역할**: Next.js가 게이트웨이 역할도 하면서 동시에 새 기능 개발도 담당

모든 요청이 `podo.re-speak.com`으로 들어오지만, 뒤에서는 적절한 곳으로 보내준다.

### 인증 과정 간단해짐

```javascript
// 전에: 복잡한 도메인 간 처리
User → Next.js (login) → OAuth → Next.js (token handling)
  → URL parameters → Nuxt.js (token processing) → Home

// 지금: 한 도메인에서 처리
User → Next.js App Shell (login) → OAuth
  → Next.js (cookie management) → Internal rewrite to Nuxt.js → Home
```

모든 과정이 podo.re-speak.com에서 일어나니까 쿠키 공유가 자연스럽게 되고, 사용자 경험도 훨씬 좋아졌다.

## 4개월간의 삽질

하지만 이 과정이 4개월이나 걸린 이유는 단순히 기술적 구현만의 문제가 아니었다.

### 데이터 기반 의사결정의 중요성

우리 팀은 모든 결정을 데이터에 기반해서 한다. 마케터들은 GA 데이터를 보고:
- 어떤 채널에서 유저가 많이 들어오는지 분석
- 효과 좋은 광고에 예산을 더 투입
- 프로덕트 로드맵도 유입 채널별 성과를 보고 결정

그런데 도메인이 여러 개로 나뉘어 있다 보니 GA 트래킹이 제대로 안 됐다.

### 12월부터 시작된 GA 지옥

**문제의 시작: (not set) 폭증**

12월부터 GA에서 세션 소스가 `(not set)`으로 뜨는 비율이 75%까지 치솟았다. 마케터 입장에서는 재앙이었다.

- 어떤 광고가 효과 있는지 모르겠음
- 유저가 어디서 오는지 추적 불가
- 데이터 기반 의사결정이 불가능해짐

**첫 번째 해결 시도**

도메인 간 크로스 도메인 트래킹을 설정했다. 결과적으로 `(not set)` 문제는 해결됐지만...

**새로운 문제 등장**

> "이제 세션소스 (not set)으로 떨어지는 현상은 사라졌으나, app.podospeaking.com과 podo.re-speak.com이 외부 사이트로 인식되어 direct / none 비중이 줄어들지는 않았습니다."

내부 사이트끼리 이동하는 것도 외부 유입으로 잡혔다. 실제 광고 효과를 정확히 측정할 수 없는 상황이었다.

**페이스리프팅 후 또 다른 문제**

Multi-zone 아키텍처로 문제를 해결했다고 생각했는데, 페이스리프팅을 하면서 또 GA 이슈가 발생했다.

- 페이지 전환 시 트래킹 이벤트 누락
- SPA와 전통적인 페이지 전환이 섞이면서 이벤트 중복 발생
- 퍼널 분석 데이터가 부정확해짐

**마케터와의 협업**

> "준형님이 nextjs multizone 도입을 통해 php, vue, react를 한 도메인에서 접속할 수 있도록 세팅해주셨습니다"

마케터들과 매주 회의를 하면서:
- GA 데이터 정합성 체크
- A/B 테스트 결과 검증
- 트래킹 이벤트 누락 여부 확인

이런 과정을 반복하면서 점차 개선해 나갔다.

## 결과는 어땠을까

### 개발팀: 개발이 쉬워졌다

- 새로운 코드베이스에서 코딩할 수 있게 됐다
- 쿠키 지옥에서 탈출했다

### 하나로 통합된 사용자 경험

- **하나의 도메인에서 모든 기능**: 사용자는 도메인이 바뀌는 걸 모름
- **깔끔한 네비게이션**: 복잡한 리다이렉트 과정 사라짐
- **부드러운 페이지 이동**: Hard/Soft Navigation을 적절히 조합

### 각자 독립적으로 개발

- **각 팀이 원하는 기술 스택 사용**: PHP, Nuxt.js, Next.js 그대로 유지
- **독립적으로 배포**: 각 존별로 따로 배포 가능
- **점진적 이전**: 기존 시스템 놔두고 새로 만들기

### 성능도 좋아짐

- **중복 제거**: 정적 파일들 효율적으로 관리
- **캐싱 최적화**: 각 존별로 최적화된 캐싱
- **번들 관리**: 독립적으로 번들 관리

### 운영도 편해짐

시스템 바꾸는 건 개발팀만을 위한 게 아니어야 한다. 조직이 원하는 것도 만족시켜줘야 하니까.

- **도메인 관리 통합**: 하나의 도메인에서 모든 서비스
- **장애 포인트 감소**: 인증 복잡성 해결로 문제 줄어듦
- **데이터 분석 정확해짐**: GA 데이터 정합성 75% → 21%로 개선

### 마케팅팀도 행복해짐

가장 큰 성과는 마케팅 데이터 정확성이 크게 개선된 것이다.

**Before: 데이터 지옥**
- `(not set)` 비율 75% (어디서 온 유저인지 모름)
- 도메인 간 이동이 외부 유입으로 잘못 집계
- A/B 테스트 결과 신뢰할 수 없음
- 광고 예산 배분 근거 없음

**After: 정확한 데이터**
- `(not set)` 비율 21%로 대폭 감소
- 실제 유입 채널별 정확한 성과 측정 가능
- 퍼널 분석 데이터 신뢰성 확보
- 데이터 기반 의사결정 복원

이제 마케터들이 "이 광고 효과 좋으니 예산 더 투입하자"라고 자신 있게 말할 수 있게 됐다.

## 회고: 기술이 비즈니스를 구하다

이 프로젝트는 단순히 "쿠키를 공유하자"는 문제가 아니었다.

- **개발자 입장**: 인증 흐름 통합과 유지보수 비용 감소
- **마케터 입장**: 정확한 유입 추적과 광고 효율 향상
- **운영팀 입장**: 로그인 이슈 감소로 CS 부담 완화
- **데이터팀 입장**: 전환 퍼널/세션 분석 가능

Next.js의 멀티존 기능은 마치 백엔드 게이트웨이처럼 작동하여, 우리가 바꾸고 싶었던 거의 모든 부분을 매끄럽게 연결시켜 주었다.

### 핵심 정리

| 항목 | 전(before) | 후(after) |
|------|-----------|-----------|
| 도메인 구조 | cross-domain | same-domain multi-zone |
| 쿠키 공유 | 불가 | 가능 |
| GA/GTM 세션 추적 | not set 문제 | 유입 추적 가능 |
| 마케팅 데이터 | 광고 최적화 어려움 | 캠페인 성과 분석 가능 |
| 인증 흐름 | 혼란스러움 | 통합됨 |

이 아키텍처 변화는 단순한 기술 개편이 아니라, **제품, 마케팅, 데이터 조직 전체에 임팩트를 준 변화**였다.

기술부채를 해결하는 건 단순히 코드를 정리하는 게 아니다. 조직의 비즈니스가 계속 돌아가도록 해야 한다는 걸 배우고 실천해본 경험이었다.
